<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.23">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2021-01-22">

<title>Reading List 100—In memory of Rodrigo Maeda – Sensorimotor Superlab</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-dark-7271f29f9498218151f3120baddb7363.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-226bd0f977fa82dfae4534cac220d79a.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-f064d1f98a45d34bcfcf43f7c07d5309.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../site_libs/bootstrap/bootstrap-dark-487f3cf8c7f75cb6ca247a16ed6538b2.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<link href="../site_libs/bootstrap/bootstrap-f064d1f98a45d34bcfcf43f7c07d5309.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme-extra" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="nav-fixed fullcontent quarto-light"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    window.setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      window.setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    window.hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(darkModeDefault) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const darkModeDefault = false;
    document.querySelector('link.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !window.hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
    };
    // Switch to dark mode if need be
    if (window.hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../wusmsl_logo.png" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Sensorimotor Superlab</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../subscribe.html"> 
<span class="menu-text">Subscribe</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../join.html"> 
<span class="menu-text">Join the Superlab</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/sensorimotor-superlab/sensorimotor-superlab.github.io"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="../index.xml"> <i class="bi bi-rss" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">


<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Reading List 100—In memory of Rodrigo Maeda</h1>
  <div class="quarto-categories">
    <div class="quarto-category">readinglist</div>
  </div>
  </div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">January 22, 2021</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="section" class="level1">
<h1></h1>
<p><img align="left" data-file-id="1701786" height="280" src="https://mcusercontent.com/5123e51e6c72da00386654148/images/b16681c0-7d8a-4836-9e43-431e1e55c2ae.jpg" style="border: 0px  ; width: 193px; height: 280px; float: left; margin: 7px 15px 3px 0px;" width="193"></p>
<p>For the 100th Superlab Reading List, we honour the scientific legacy of Superlab PhD Student, <strong>Rodrigo Maeda</strong>, who passed away from stomach cancer on January 1st, 2021.</p>
<p>Rodrigo came to Western in Fall 2015 after completing his MSc at Simon Fraser University under the supervision of Drs. Dan Marigold and Max Donelan. He was the first PhD student with Andrew Pruszynski and was co-supervised by Paul Gribble. Rodrigo was scheduled to defend his thesis on January 18th, 2021 to a committee that consisted of Drs. Brian Corneil, Jody Culham, Julio Martinez-Trujillo and Daniel Wolpert (Columbia), an event about which we were all extremely excited. Rodrigo was planning to move on to Baltimore and start a postdoctoral fellowship with Dr.&nbsp;Kathy Cullen (Johns Hopkins) in Summer 2021.</p>
<p>Rodrigo was an exceptional young scientist, a friendly and generous colleague, and a kind young man. He had an unmatched work ethic in the lab, driven by a natural curiosity for science and an appreciation of the power of a carefully designed experiment paired with a high quality dataset. Rodrigo was a great collaborator—quiet and reserved by nature but generous with his time and scientific ideas. He could already identify important gaps in the field and always made a compelling argument about what experiment to do next, usually armed with a quietly acquired new pilot data set. He even convinced Andrew to get into motor learning studies.</p>
<p>Below, Rodrigo’s fellow Superlab members and his former supervisors provide a brief synopsis of his ten lead author publications. The scope, number, and quality of these papers is a reflection of Rodrigo’s exceptional potential as a researcher in sensorimotor neuroscience. He will be missed.</p>
<p>—Andrew, Paul, &amp; Jörn</p>
<p align="right">
Rodrigo’s <a href="https://scholar.google.com/citations?user=z2l87YMAAAAJ&amp;hl=en">Google Scholar profile</a>
</p>
<section id="section-1" class="level2">
<h2 class="anchored" data-anchor-id="section-1">1</h2>
<p><strong>Feedforward and Feedback Control Share an Internal Model of the Arm’s Dynamics</strong><br>
Maeda RS, Cluff T, Gribble PL, Pruszynski JA<br>
J Neurosci 38:10505–10514 (2018)<br>
<a href="https://www.jneurosci.org/content/38/49/10505.abstract">https://www.jneurosci.org/content/38/49/10505.abstract</a></p>
<p>In this study, Rodrigo and colleagues tested whether altering the arm’s intersegmental dynamics during voluntary reaching movements influences feedback control—specifically, the long latency stretch reflex. Participants performed voluntary reaching movements between two targets placed so that mainly elbow motion was required. As the elbow joint normally rotates into flexion, passive extension torque occurs at the shoulder due to the limb’s intersegmental dynamics. In previous work by Rodrigo and by others, it has been shown that the nervous system uses an internal model of limb dynamics to anticipate these torques, and thus activates shoulder flexor muscles to keep the shoulder joint stationary. In this study, the shoulder joint of a KINARM exoskeleton robot was mechanically locked to stabilize the shoulder against interaction torques arising from elbow rotation. Over hundreds of trials, participants learned to decrease shoulder muscle activity while performing elbow rotation movements. Rodrigo and colleagues also probed the long latency stretch reflex in pectoralis muscle by delivering mechanical perturbations to the arm before and after the learning session (with the shoulder joint unlocked). Prior to learning, the long latency stretch reflex was large in pectoralis. Importantly, after learning, this reflex was substantially reduced in magnitude. Learning novel intersegmental limb dynamics through voluntary reaching thus also results in changes to feedback control. These findings support the idea that feedforward and feedback movement control share an internal model of limb dynamics.</p>
<p>—<em>Chris Forgaard</em></p>
</section>
<section id="section-2" class="level2">
<h2 class="anchored" data-anchor-id="section-2">2</h2>
<p><strong>Compensating for intersegmental dynamics across the shoulder, elbow, and wrist joints during feedforward and feedback control</strong><br>
Maeda RS, Cluff T, Gribble PL, Pruszynski JA<br>
J Neurophysiol 118:1984–1997 (2017)<br>
<a href="https://journals.physiology.org/doi/abs/10.1152/jn.00178.2017">https://journals.physiology.org/doi/abs/10.1152/jn.00178.2017</a></p>
<p>Controlling the movement of our arms is a challenging problem for the nervous system. One reason is because muscle torque applied at one joint (e.g.&nbsp;the shoulder) results in passive torques at other joints (e.g.&nbsp;the elbow and wrist), causing those joints to rotate. This is an example of ‘intersegmental dynamics’, which the nervous system must account for to make accurate reaching movements. In this work, Rodrigo and colleagues completed four experiments to test how well the nervous system compensates for intersegmental dynamics that arise between the shoulder, elbow and wrist when people produce voluntary reaching movements and when they respond to the arm being unexpectedly perturbed. In Experiment 1, participants performed voluntary elbow flexion and extension movements at different speeds. Rodrigo showed that the timing and amplitude of shoulder muscle activity was produced in a predictive manner to counteract the passive shoulder movement that would have been caused by the participants’ elbow movements. In Experiment 2, participants performed voluntary wrist flexion and extension movements and Rodrigo showed that elbow muscle activity was produced in a predictive way to counteract the passively generated torques that would have rotated the elbow. In Experiment 3 and 4, participants produced voluntary elbow flexion or extension movement or countered an external perturbation that flexed or extended the elbow (exp 4). In each of these experiments, participants completed trials with their wrist in a flexed position and in an extended position, which alters how the passively generated torque propagates to the shoulder. Rodrigo showed in both experiments that shoulder muscle activity was generated to counteract the passive rotational forces produced at the shoulder from the elbow’s movement, and that this shoulder muscle activity was appropriately tuned to how changes in the participants’ wrist orientation changed the intersegmental dynamic effects observed at the shoulder. These experiments collectively provide strong evidence that the nervous system robustly predicts and accounts for intersegmental dynamics across the shoulder, elbow and wrist during reaching and when counteracting external perturbations.</p>
<p>—<em>Jeff Weiler</em></p>
</section>
<section id="section-3" class="level2">
<h2 class="anchored" data-anchor-id="section-3">3</h2>
<p><strong>Consolidation of visuomotor adaptation memory with consistent and noisy environments</strong><br>
Maeda RS, McGee SE, Marigold DS<br>
J Neurophysiol 117:316–326 (2017)<br>
<a href="https://journals.physiology.org/doi/abs/10.1152/jn.00178.2016">https://journals.physiology.org/doi/abs/10.1152/jn.00178.2016</a></p>
<p>When it’s time to retire an old set of tennis balls to dog duty and you pop open a new can, you have to quickly adapt your game to the new, more bouncy balls. This process might be faster if you can use motor memories of previous times you played with fresh tennis balls. Motor adaptation like this, and the resulting motor memories, have been extensively studied in visually guided reaching paradigms, in which the relation between movement of the hand and a cursor is altered. Foot placement is another motor action we frequently adapt—to avoid sidewalk cracks or to splash in the largest puddle—but it is less studied in this context. Rodrigo and colleagues investigated whether some hallmarks of upper limb visuomotor adaptation apply in a task where participants had to walk quickly and step on targets while their vision of those targets was shifted to the left or right with prism glasses. They found that participants quickly learned to adapt their walking to a prism induced visual perturbation, and that the motor memory of this adaptation was largely retained at a retest session a week later. Previous experiments using reaching movements have shown that when adaptation to one visual perturbation is followed by exposure to another perturbation in the opposite direction, the motor memory of the original adaptation can be lost or degraded; however, motor memories also become resistant to such interference over time via a process known as consolidation. Rodrigo et al.&nbsp;found that, despite some interference by an opposing prism shift, motor memories during the walking tasks were largely retained, indicating consolidation. Interestingly, consolidation in these tasks appeared to occur in a matter of minutes, unlike consolidation of reach adaptation which can take hours. Differences like this between visually guided hand and foot movements are especially intriguing because unlike hand movement, foot placement is highly constrained by the timing of the gait cycle and our strong desire not to fall over.</p>
<p>—<em>Sasha Reschechtko &amp; Dimitri Palidis</em></p>
</section>
<section id="section-4" class="level2">
<h2 class="anchored" data-anchor-id="section-4">4</h2>
<p><strong>Learning New Feedforward Motor Commands Based on Feedback Responses</strong><br>
Maeda RS, Gribble PL, Pruszynski JA<br>
Curr Biol 30:1941–1948.e3 (2020)<br>
<a href="https://www.sciencedirect.com/science/article/pii/S0960982220303419">https://www.sciencedirect.com/science/article/pii/S0960982220303419</a></p>
<p>In previous work, Rodrigo and colleagues demonstrated that the nervous system accounts for changes in upper limb intersegmental limb dynamics. These changes are not only learned during feedforward motor control (voluntary reaching movements), they can also alter rapid feedback responses to mechanical perturbations. Rodrigo and colleagues further demonstrated that since these rapid feedback responses are partly mediated by neural circuits that are also recruited during voluntary reaches, learning altered limb dynamics during feedforward motor control transferred to feedback responses evoked to mechanical perturbations. Here, the Rodrigo tested the reverse hypotheses: Do altered intersegmental dynamics learned through feedback responses transfer to feedforward motor control? To test this, the shoulder joint of a KINARM exoskeleton robot was mechanically locked, so that the participants’ shoulder joint was prevented from rotating, thus stabilizing it in the face of interaction torques arising at the shoulder due to elbow rotation. During an adaptation phase (shoulder locked), participants passively experienced hundreds of very short mechanical perturbations applied to the shoulder and elbow joints that resulted in pure elbow motion. After these perturbations and with the shoulder still locked, participants made 10 voluntary reaches to a target. By comparing these 10 reaches from to reaches made before and after the adaptation phase (with the shoulder joint unlocked), Maeda and colleagues demonstrated two effects. First, shoulder muscle activity was reduced during reaches performed at the end of the adaptation phase. Second, there were kinematic errors in the reach trajectories (i.e.&nbsp;aftereffects) during the initial reaches completed after the shoulder was unlocked. These kinematic errors occurred in the direction predicted if participants did not compensate for torques that would normally arise at the shoulder joint when producing the required reaches. Taken together, these results demonstrate that learning novel intersegmental limb dynamics through feedback responses transfers to feedforward motor control. Furthermore, in conjunction with previous work, this demonstrates that transfer between feedforward and feedback movement control is bidirectional, and further supports the idea that feedforward and feedback control share an internal model of limb dynamics.</p>
<p>—<em>Spencer Arbuckle</em></p>
</section>
<section id="section-5" class="level2">
<h2 class="anchored" data-anchor-id="section-5">5</h2>
<p><strong>Generalizing movement patterns following shoulder fixation</strong><br>
Maeda RS, Zdybal JM, Gribble PL, Pruszynski JA<br>
J Neurophysiol 123:1193–1205 (2020)<br>
<a href="https://journals.physiology.org/doi/abs/10.1152/jn.00696.2019">https://journals.physiology.org/doi/abs/10.1152/jn.00696.2019</a></p>
<p>When an individual performs a movement involving only elbow joint rotation, rotational forces arise at the shoulder joint, leading to an intersegmental “interaction torque”. In previous work, Rodrigo and colleagues demonstrated that the nervous system compensates for this interaction torque using shoulder muscle activation. The nervous system can even learn to reduce this compensatory activity when the interaction torque is artificially removed by mechanically fixing the shoulder joint. In this study, Rodrigo and colleagues asked whether this learning generalises to different arm configurations and different reach kinematics. Testing for these possibilities allowed them to probe the specificity of intersegmental dynamics representation within internal models. For instance, changing initial shoulder angle does not alter the elbow-to-shoulder mapping of intersegmental interaction torques but changing initial elbow angle does. Changing elbow reach kinematics (speed, distance) scales the interaction torques but they remain proportional to that of the original reach. Experimentally, the authors then showed that newly learned intersegmental dynamics generalised to new initial shoulder angles or reaching kinematics, but not to new initial elbow angles. This discrepancy reveals that newly acquired representations of intersegmental interactions in internal models generalise only to movements that should express a (proportionally) identical interaction, in line with the biomechanics of the arm.</p>
<p>—<em>Olivier Codol</em></p>
</section>
<section id="section-6" class="level2">
<h2 class="anchored" data-anchor-id="section-6">6</h2>
<p><strong>Shared internal models for feedforward and feedback control of arm dynamics in non‐human primates</strong><br>
Maeda RS, Kersten R, Andrew Pruszynski J<br>
Eur J Neurosci. 2020; 1– 16.<br>
<a href="https://onlinelibrary.wiley.com/doi/10.1111/ejn.15056">https://onlinelibrary.wiley.com/doi/10.1111/ejn.15056</a></p>
<p>As humans, we are able to learn new patterns of muscle activity to deal with new situations and challenges. We do this in part by using errors in our performance to update our model of the environment to generate successful actions. Furthermore, it has been shown that these updates are shared between feedforward actions and feedback responses following mechanical perturbations. In a previous study, Rodrigo and colleagues (2018) performed an elegant experiment showing that similar updates occur when the dynamics of the arm change. Normally, elbow movement requires muscle activity of the elbow and shoulder muscles due to the intersegmental dynamics of the arm. However, they found that immobilizing the shoulder joint during elbow movements reduced muscle activity in shoulder muscles slowly over time, the appropriate response for performing the task efficiently. Interestingly, these updates occur in the absence of any explicit errors, suggesting that updating an internal model of arm dynamics does not require error-based feedback. In the current work, Rodrigo and colleagues performed a similar experiment on non-human primates and confirmed that the same results hold in both humans and non-human primates, suggesting a similar adaptation process for an internal model of arm dynamics. Importantly, as in the human experiment, the non-human primates did not have experience with shoulder locking prior to experiments. Demonstrating this striking similarity between human and non-human primates will now allow further non-human primate experiments that investigate the neural basis of this adaptation, shedding light on how the brain updates its internal model of arm dynamics and how these models are shared between feedforward and feedback control.</p>
<p>—<em>Jonathan Michaels</em></p>
</section>
<section id="section-7" class="level2">
<h2 class="anchored" data-anchor-id="section-7">7</h2>
<p><strong>Sensory information from a slipping object elicits a rapid and automatic shoulder response</strong><br>
*Hernandez-Castillo CR, *Maeda RS, Pruszynski JA, Diedrichsen J<br>
(* co-first author)<br>
J Neurophysiol 123:1103–111 (2020)<br>
<a href="https://journals.physiology.org/doi/full/10.1152/jn.00672.2019">https://journals.physiology.org/doi/full/10.1152/jn.00672.2019</a></p>
<p>Imagine you were holding a coffee mug which began to slip from your hand. You would immediately compensate for that slip, preventing that mug from falling and spilling the coveted coffee. Previous studies have shown that the grip force in the hand increases in response to such slips. Studies have also shown that there is a compensatory motor response in the arm when perturbed. Although one can imagine that the arm and the hand work together to keep that mug of coffee in your hand, most previous studies investigated the changes in the arm and hand separately. Interestingly, one study showed that the hand muscles (and precision grip) adapted rapidly when the arm was perturbed. In this study, Carlos and Rodirgo investigated the complementary question: is there a rapid automatic response in the arm in response to sensory information about slipping from the hand? To answer these questions, Carlos and Rodrigo used a custom device that emulated slipping. When the coffee mug slips from your hand, you not only feel the slip in your hands, but proprioceptive information present in the action would also be transmitted to the arm. Carlos and Rodrigo mounted their custom device on a robotic exoskeleton to isolate the proprioceptive feedback from the hand and ensure that any response they saw in the upper arm was solely in response to the sensory input from the hands. They performed three experiments with 14 human participants using their custom slip device. They demonstrated that sensory information from the fingertips during a slip elicited a rapid motor response from the shoulder. This rapid automatic response is useful for stabilizing handheld objects and is faster in the direction of the slip. That is, when that coffee mug slips from your hand, there is an automatic rapid corrective motor response from your shoulder in the direction of the slip, based solely on the sensory information from your fingertips.</p>
<p>—<em>Vaishnavi Sukumar</em></p>
</section>
<section id="section-8" class="level2">
<h2 class="anchored" data-anchor-id="section-8">8</h2>
<p><strong>Foot placement relies on state estimation during visually guided walking</strong><br>
Maeda RS, O’Connor SM, Donelan JM, Marigold DS<br>
J Neurophysiol 117:480–491 (2017)<br>
<a href="https://journals.physiology.org/doi/abs/10.1152/jn.00015.2016">https://journals.physiology.org/doi/abs/10.1152/jn.00015.2016</a></p>
<p>Accurate foot placement is essential to stabilize our motion and to navigate our environment. The nervous system must achieve this accuracy despite imperfect sensory feedback and unexpected perturbations. In this study Rodrigo and colleagues used computational models and human walking experiments to test whether the nervous system uses state estimation to beneficially combine sensory feedback with forward model predictions to compensate for these challenges. Participants wore prism lenses during a visually guided walking task that required them to precisely step on a target in the middle of a path. These lenses altered the mapping relationship between the perceived target location and the motor command necessary to direct the foot to that position. The magnitude and direction of prism shifts varied on a trial to trial basis to add noise to the visual feedback and induce a re-weighting of this input. To expose altered weighting, a consistent prism shift was added. With added prism noise, participants responded to the consistent prism shift with smaller initial foot placement error but took longer to adapt. This matched the predictions of a mathematical model of the walking task that leveraged state estimation to compensate for noise. A model driven by task error did not support the behavioural data. Overall, the results are similar to recent computational neuroscience findings for reaching movements, suggesting that state estimation is a general mechanism of human motor control. On a personal note, the research underpinning this paper was the first collaborative effort between the Marigold and Donelan labs. The collaboration was stimulated by Rodrigo and is one of the many enduring effects that he has had on science and on our lives.</p>
<p>–<em>Dan Marigold &amp; Max Donelan</em></p>
</section>
<section id="section-9" class="level2">
<h2 class="anchored" data-anchor-id="section-9">9</h2>
<p><strong>Long-term retention and reconsolidation of a visuomotor memory</strong><br>
Maeda RS, McGee SE, Marigold DS<br>
Neurobiol Learn Mem 155:313–321 (2018)<br>
<a href="https://www.sciencedirect.com/science/article/pii/S1074742718302168">https://www.sciencedirect.com/science/article/pii/S1074742718302168</a></p>
<p>Memories are known to be fragile and susceptible to interfering information upon retrieval, but does this apply to visuomotor memories in the context of walking? Rodrigo and colleagues addressed this question in a walking adaptation paradigm by using prism glasses that shifted participants’ perception of future stepping targets (e.g., by ~10° to the left of the actual location). After only a few (1-10) trials, participants learned to accurately step in the center of the shifted targets. The memory of this visuomotor mapping (A) was retained even a year later in a retest session, as demonstrated by faster relearning of the prism shift (i.e., savings). To assess whether motor memories are fragile upon reactivation, in the retest session, after performing mapping A, participants were exposed to an interfering mapping B (e.g., prism shift to the right). If memories need to reconsolidate, this should cause larger foot placement errors when reverting back to mapping A. In contrast, the authors found no evidence of decreased performance, suggesting that the opposing mapping did not disrupt the original memory. In a separate group of participants, Rodrigo asked whether presenting the opposing mapping (B) in the initial session, immediately after learning mapping A, would disrupt long-term retention of the original mapping (A), but again there was no disruption. Interestingly, these participants who experienced both types of adaptation in the initial and 1-year retest sessions retained not only the original mapping (A), but also the opposing mapping (B), suggesting that humans can form multiple visuomotor memories for walking. This series of experiments demonstrates that visuomotor memories for walking are stable, easily consolidated for long-term usage, and robust against interference.</p>
<p>—<em>Eva Berlot &amp; Giacomo Ariani</em></p>
</section>
<section id="section-10" class="level2">
<h2 class="anchored" data-anchor-id="section-10">10</h2>
<p><strong>From Specific Training to Global Shift of Manual Preference in Kung Fu Experts</strong><br>
Maeda RS, Souza RM, Teixeira LA<br>
Percept Mot Skills 118:73–85 (2014)<br>
<a href="https://journals.sagepub.com/doi/abs/10.2466/23.25.PMS.118k12w5">https://journals.sagepub.com/doi/abs/10.2466/23.25.PMS.118k12w5</a></p>
<p>Here Rodrigo and colleagues demonstrate that intermanual performance asymmetry and manual preference in daily tasks is weaker in Kung Fu experts compared to novices. They compared the performance speed of typical unilateral Kung Fu movements between right-handed experts with 5 or more years of experience in Kung Fu to novices with less than 1 year of experience. They found that intermanual performance asymmetry between right and left upper limb movements were diminished in experts. In other words, Kung Fu experts showed superior bimanual performance. Interestingly, this behavior extended to daily tasks that were unrelated to the Kung Fu movements. Their results suggest that the intermanual Kung Fu training might have weakened the dominant hand preference for tasks unrelated to the practiced movements. Their findings support the model of dynamic formation of manual preference by Teixeira and colleagues (2010) which suggests that lateralized training can modulate the strength of manual preference which in turn is generalized across various motor tasks. This paper shows a potential link between lateralized training and manual preference for tasks unrelated to the specific training.</p>
<p>—<em>Nicola Popp &amp; Carlos Hernandez-Castillo</em></p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    window.setColorSchemeToggle(window.hasAlternateSentinel())
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/superlab\.ca");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>