<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2021-02-19">

<title>Reading List 102 – Sensorimotor Superlab</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../wusmsl_logo.png" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Sensorimotor Superlab</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../subscribe.html"> 
<span class="menu-text">Subscribe</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../join.html"> 
<span class="menu-text">Join the Superlab</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/sensorimotor-superlab/sensorimotor-superlab.github.io"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="../index.xml"> <i class="bi bi-rss" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Reading List 102</h1>
  <div class="quarto-categories">
    <div class="quarto-category">readinglist</div>
  </div>
  </div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">February 19, 2021</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="section" class="level1">
<h1></h1>
<p>Here are the articles that have piqued our interest this week.</p>
<p>Enjoy!<br>
—the superlab</p>
<section id="section-1" class="level2">
<h2 class="anchored" data-anchor-id="section-1">1</h2>
<p><strong>Striatal bilateral control of skilled forelimb movement</strong><br>
Lopez-Huerta, V. G., Denton, J. A., Nakano, Y., Jaidar, O., Garcia-Munoz, M., &amp; Arbuthnott, G. W.<br>
Cell Reports (2021), 34(3), 108651. <a href="https://doi.org/10.1016/j.celrep.2020.108651">https://doi.org/10.1016/j.celrep.2020.108651</a></p>
<p>We perform highly dexterous reaching and grasping movements that allow us to interact with the objects in our environments. Unlike the cortex, little is known about the role of the basal ganglia nuclei in bilaterally modulating skilled reaching. Lopez-Huerta et al.&nbsp;show that two distinct populations of striatal projection neurons from ipsi- and contralateral hemispheres modulate unimanual reaching tasks. They also reveal an increased connectivity for these projection neurons as a direct result of training to perform the skilled reaching task. The long lasting effect of learning the skill, seen in the changed circuit connectivity, raises interesting questions about the effect of training and the bilateral control of unimanual movements.<br>
—<em>Vaishnavi Sukumar</em> [ <a href="https://scholar.google.com/citations?user=sKpKFYwAAAAJ&amp;hl=en">google scholar</a> | <a href="https://twitter.com/Vaishu_Sukumar">twitter</a>]</p>
</section>
<section id="section-2" class="level2">
<h2 class="anchored" data-anchor-id="section-2">2</h2>
<p><strong>An implicit memory of errors limits human sensorimotor adaptation</strong><br>
Albert, S. T., Jang, J., Sheahan, H., Teunissen, L., Vandevoorde, K., &amp; Shadmehr, R.<br>
Nature Human Behaviour (2021). <a href="https://www.nature.com/articles/s41562-020-01036-x">https://www.nature.com/articles/s41562-020-01036-x</a></p>
<p>Here, Albert et al.&nbsp;(2021) investigate the persistence of residual errors during motor adaptation in the context of implicit and explicit learning systems. In order to understand the influence of variability as a limiting factor for adaptation, they evaluated how participants adapted to constant and variable perturbations. They observed that learning supported by the explicit system was not influenced by perturbation variance, whereas adaptation which depended largely on the implicit system was altered by variability. They propose that the implicit learning system modulates the sensitivity to error by maintaining a memory for prior errors, thereby limiting sensorimotor adaptation.<br>
—<em>Susan Coltman</em> [ <a href="https://scholar.google.ca/citations?user=fI2YLbMAAAAJ">google scholar</a> | <a href="https://twitter.com/SusanColtman04">twitter</a> ]</p>
</section>
<section id="section-3" class="level2">
<h2 class="anchored" data-anchor-id="section-3">3</h2>
<p><strong>Brief stimuli cast a long-term trace in visual cortex</strong><br>
Fritsche, M., Solomon, S. G., &amp; de Lange, F. P.<br>
bioRxiv (2021). <a href="https://doi.org/10.1101/2021.02.10.430579">https://doi.org/10.1101/2021.02.10.430579</a></p>
<p>Stimulus history affects sensory processing as well as neuronal firing, exhibited as reduced neuronal firing in response to stimulus repetition (i.e.&nbsp;adaptation), but what is the timescale of these adaptation effects? Fritsche and colleagues used a dataset from the Allen Brain Observatory to demonstrate that neurons in the mouse visual system show a remarkably prolonged adaptation to repeated visual stimuli over dozens of seconds, even in the presence of intervening stimuli, whereas thalamic neurons only exhibit short-term adaptation. This indicates that long-term adaptation of the visual cortex relies on cortical short-term plasticity (and is not inherited from thalamus), and might enable the visual cortex to form a statistical representation of the world over multiple timescales.<br>
—<em>Eva Berlot</em> [ <a href="https://scholar.google.com/citations?user=JTC6M_MAAAAJ">google scholar</a> | <a href="https://twitter.com/EvaBerlot">twitter</a> ]</p>
</section>
<section id="section-4" class="level2">
<h2 class="anchored" data-anchor-id="section-4">4</h2>
<p><strong>PIEZO2 in sensory neurons and urothelial cells coordinates urination</strong><br>
Marshall, K. L., Saade, D., Ghitani, N., Coombs, A. M., Szczot, M., Keller, J., Ogata, T., Daou, I., Stowers, L. T., Bönnemann, C. G., Chesler, A. T., &amp; Patapoutian, A.<br>
Nature (2020), 588(7837), 290–295. <a href="https://doi.org/10.1038/s41586-020-2830-7">https://doi.org/10.1038/s41586-020-2830-7</a></p>
<p>Despite its importance, our understanding of sensory information processing in the lower urinary tract is surprisingly limited. In this study, Marshall et al.&nbsp;show that the mechanosensitive ion channel PIEZO2 is expressed in lower urinary tract tissues and its innervating sensory neurons, playing an important role in the micturition reflex and bladder-stretch sensation. In the context of behaviour, lacking functional PIEZO2 is associated with bladder control impairment in both men and mice. This work can be a stepping stone for a better understanding of the interactions between the sensory system and urothelial cells, leading to an enhancement in medical interventions for lower urinary tract pathologies.<br>
—<em>Mehrdad Kashefi</em> [ <a href="https://scholar.google.com/citations?user=JWIhhAUAAAAJ&amp;hl=en">google scholar</a> | <a href="https://twitter.com/mehrdadkashefi">twitter</a> ]</p>
</section>
<section id="section-5" class="level2">
<h2 class="anchored" data-anchor-id="section-5">5</h2>
<p><strong>Interhemispheric transfer of working memories</strong><br>
Brincat, S. L., Donoghue, J. A., Mahnke, M. K., Kornblith, S., Lundqvist, M., &amp; Miller, E. K.<br>
Neuron (2021). <a href="https://doi.org/10.1016/j.neuron.2021.01.016">https://doi.org/10.1016/j.neuron.2021.01.016</a></p>
<p>How we use visual information in our everyday life feels seamless, but the scaffolding of the visual system would suggest anything but. Visual stimuli presented to the left and right visual hemifields project to the right and left hemispheres, respectively. How does one hemisphere access visual information that was presented to the other hemisphere? In this paper, Brincat and colleagues investigated this using a task that required information about a visually presented object to be transferred across hemispheres after the object was removed from view. By recording from neurons bilaterally in the prefrontal cortex (a region thought to play a critical role in visual working memory processes), Brincat and colleagues demonstrated that visual information is transferred between hemispheres, and not simply accessed by the other hemisphere when necessary. Furthermore, the local populations of neurons that encode the visual working memory are different when the visual information is originally “seen” by that hemisphere versus when it is transferred across hemispheres. The next exciting questions are likely to focus on how this transfer happens, and how behaviourally-relevant information present in both visual hemifields is integrated in the brain.<br>
—<em>Spencer Arbuckle</em> [ <a href="https://saarbuckle.com/">website</a> | <a href="https://twitter.com/saarbuckle">twitter</a> ]</p>
</section>
<section id="section-6" class="level2">
<h2 class="anchored" data-anchor-id="section-6">6</h2>
<p><strong>Area-specific thalamocortical synchronization underlies the transition from motor planning to execution</strong><br>
Nashef, A., Mitelman, R., Harel, R., Joshua, M., &amp; Prut, Y.<br>
PNAS (2021), 118(6). <a href="https://doi.org/10.1073/pnas.2012658118">https://doi.org/10.1073/pnas.2012658118</a></p>
<p>Despite their hypothesized role in regulating neuronal firing in sensory and motor areas, thalamic contributions to cortical activity remain poorly understood. To investigate peri-movement thalamocortical interactions, Nashef and colleagues simultaneously recorded the activity of pre-identified thalamic and cortical (motor and premotor) neurons while non-human primates performed a delayed-response reaching task. Analysis of multi-site correlation patterns revealed that thalamic signals had a positive impact on neuronal activity in the primary motor cortex and a negative impact on neuronal activity in the premotor cortex. The authors conclude that the thalamus can either enhance or suppress local cortical dynamics around movement onset, driving the shift from motor plan to action.<br>
—<em>Giacomo Ariani</em> [ <a href="https://scholar.google.com/citations?user=IYbgVnUAAAAJ">google scholar</a> | <a href="https://twitter.com/GiacomoAriani">twitter</a> ]</p>
</section>
<section id="section-7" class="level2">
<h2 class="anchored" data-anchor-id="section-7">7</h2>
<p><strong>Mechanoreceptor synapses in the brainstem shape the central representation of touch.</strong><br>
Lehnert, B. P., Santiago, C., Huey, E. L., Emanuel, A. J., Renauld, S., Africawala, N., Alkislar, I., Zheng, Y., Bai, L., Koutsioumpa, C., Hong, J. T., Magee, A. R., Harvey, C. D., &amp; Ginty, D. D.<br>
bioRxiv (2021). <a href="https://doi.org/10.1101/2021.02.02.429463">https://doi.org/10.1101/2021.02.02.429463</a></p>
<p>One of the first things we learn about somatosensory cortical areas is that more neurons respond to some regions of the body—like the glabrous skin on the palmar surface of the fingers and hand—than others. Lehnert, Santiago, and colleagues present evidence from murine models that this disproportionate cortical response is not simply a consequence of higher density of mechanoreceptors in these areas; instead, the authors show that this aspect of somatosensory representation is formed during early postnatal development via modification of connectivity between mechanoreceptors and their targets in brainstem. Surprisingly, however, this process does not appear to be driven straightforwardly by sensory stimulation of the periphery, leading the authors to propose that the strength of central connections with mechanoreceptors may instead be driven by cues related to the type of skin those mechanoreceptors innervate.<br>
—<em>Sasha Reschechtko</em> [ <a href="https://scholar.google.com/citations?hl=en&amp;user=oxyl3i8AAAAJ">google scholar</a> | <a href="https://twitter.com/res_chetko">twitter</a> ]</p>
</section>
<section id="section-8" class="level2">
<h2 class="anchored" data-anchor-id="section-8">8</h2>
<p><strong>Skin and muscle receptors shape coordinated fast feedback responses in the upper limb</strong><br>
Forgaard, C.J., Reschechtko, S., Gribble, P.L., Pruszynski, J.A.<br>
Current Opinion in Physiology (2021). <a href="https://doi.org/10.1016/j.cophys.2021.02.001">https://doi.org/10.1016/j.cophys.2021.02.001</a></p>
<p>While on a walk, your dog suddenly sprints off towards a squirrel. A rapid increase in tension on the leash jerks your arm forward and the leash begins to slip through your fingers. In less than 100 milliseconds, fast feedback responses from receptors in stretching muscles allow you to stabilize your arm and begin to haul in your squirrel-crazed dog. Simultaneously, fast feedback responses from receptors in the skin of your fingertips respond to the slipping leash, facilitating a rapid increase in grip force. Here we discuss how sensory feedback from skin and muscle is rapidly integrated to produce coordinated fast feedback responses throughout the upper limb.<br>
—<em>Chris Forgaard</em> [ <a href="https://scholar.google.com/citations?user=t_Ok9j8AAAAJ">google scholar</a> | <a href="https://twitter.com/CForgaard">twitter</a> ]</p>
</section>
<section id="section-9" class="level2">
<h2 class="anchored" data-anchor-id="section-9">9</h2>
<p><strong>Geometric models reveal behavioural and neural signatures of transforming experiences into memories</strong><br>
Heusser, A. C., Fitzpatrick, P. C., &amp; Manning, J. R.<br>
Nature Human Behaviour (2021). <a href="https://doi.org/10.1038/s41562-021-01051-6">https://doi.org/10.1038/s41562-021-01051-6</a></p>
<p>To gain insight into how human brains transform naturalistic experiences into episodic memories, Heusser and colleagues developed a novel geometric framework to model the dynamic conceptual content of an experience as a trajectory in a 2D semantic space. The authors apply this approach to an open fMRI dataset in which participants watched and recalled an episode of the TV series Sherlock and found that participants’ recall trajectories preserved the essential narrative structure found in episode annotations, but varied in the low-level details. This work reinforces the idea that memory is reconstructive, and that remembering is tantamount to mentally finding your way through a universe of thoughts.<br>
—<em>Giacomo Ariani</em> [ <a href="https://scholar.google.com/citations?user=IYbgVnUAAAAJ">google scholar</a> | <a href="https://twitter.com/GiacomoAriani">twitter</a> ]</p>
</section>
<section id="section-10" class="level2">
<h2 class="anchored" data-anchor-id="section-10">10</h2>
<p><strong>Somatosensory innervation of healthy human oral tissues</strong><br>
Moayedi, Y., Michlig, S., Park, M., Koch, A., &amp; Lumpkin, E. A.<br>
bioRxiv (2021). <a href="https://doi.org/10.1101/2021.02.03.429664">https://doi.org/10.1101/2021.02.03.429664</a></p>
<p>While we know much about how afferent input contributes to the neural control of limb movements such as reaching, comparably little is known about sensory receptors in the human orofacial system—sensors that presumably play a critical role in behaviours such as feeding (mastication and swallowing) and speech. Here Moayedi and colleagues collected biopsies from 12 brave human volunteers, sampling tissues from the tongue and palate and using immunohistochemistry to identify markers of neurons, afferents, taste cells, Merkel cells, free nerve endings, Meissner’s corpuscles, and more. They found a distribution of somatosensory endings reminiscent of the fingertips, structured around sensory neurons specialized for spatial localization of mechanical inputs and for the detection of moving stimuli. Evidence for a somatosensory basis of speech (as opposed to solely auditory) has recently been accumulating and these sorts of data provide additional insights into how afferents in the orofacial system support speech and speech motor learning.<br>
—<em>Paul Gribble</em> [ <a href="https://scholar.google.com/citations?user=kACnRf8AAAAJ">google scholar</a> | <a href="https://twitter.com/paulgribble">twitter</a>]</p>
</section>
</section>
<section id="disclaimer" class="level1">
<h1>Disclaimer</h1>
<p>More than 20 trainees and PIs from the Sensorimotor Superlab at Western University contribute to this reading list. Articles appear on this list because they caught our eye, but their appearance here is not necessarily an endorsement of the work. We hope that you find something on this list you might not otherwise have come across—but, as always, please read with a critical eye.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/superlab\.ca");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>